#!/bin/bash
# ***************************************************************************
#$1 Gets passed directly to ksallVBF.scr. Used here to specify what partmemcle 
#   types are to be processed. (G,P,He4_ or CR(causes P and He4_ , Or E for 
#   electrons)
#   For ksallVBF (minimum:up to kasallVBF.scr calling ksTrigger:
#     Atm-Telescope-Type-direction-threshold-arraytrigger specification 
#     designation: 
#     like: WUP1Deg50mv1234M2, SNHe4_1Deg50mv1234M2, SOG1Deg50mv1234M2,
#     WNG1DegS0.5Deg50mv1234M2.  
#     Giving a Type code of 'WUCR1Deg50mv1234M2 will cause 
#     both WUP1Deg50mv1234M2  and WUHe4_1Deg50mv1234M2 to be  run
#   For ksallVBF through ksArrayTrigger append the telescope designations: 
#     Like WNG20Deg2D50mv1234M2ABCD
#$2 has which script to run:  ksallVBF.scr
#        ksallVBF.scr is All-singing-all-dancing: ksKascade to ksArrayTrigger
#$3 Sort processing: Flags that a Sort will be requested and that we
#   should use the physics queue for the higher energies on Hansen/Conte. Not 
#   defined if jobs will take less than 4 hours.
#$4 QsubFileNameList file:OPTIONAL: 
#   This script creats all the .pbs shower files as requested and then submits
#   them to the appropiate queue itself. All of them.
#  If this argument is defined this script creates all the .pbs job files and 
#  then adds their names to the $QsubFileNameList file specified in this 
#  argument. The calling program (usually KSAuto.scr) then will submit the 
#  jobs in this file as it sees fit. (Used to keep the maximum allowable jobs 
#  in the queue but not more tan the maximum).
#$5 EntryStart: Default is G,E,P=1.
#$6 EntryEnd:   Default is G=45,E=44,P=45
#$7 EntryStart for HE4_: Default=5
#$8 EntryEnd for He4_: Default is 45
#$9 Optional DefineShowers(UtilityFunctions.scr)special flag(MDL) 
# *****************************************************************************
###########################################################################
#Functions to define thigs for various particle specs

function Protons()
#**********************************************************************
#Veritas/Whipple Protons
#**********************************************************************
{
  echo Protons: $parspec

  #Veritas/Whipple set1/ksaom/kasall
  #Defines energy, start and end arrays
  DefineShowers 'P' $MDL

  BuildAndSubmit
}
#**********************************************************************

function Helium4()
#**********************************************************************
#Veritas  and whipple Helium4
#**********************************************************************
{
  echo Helium4: $parspec
  #Defines energy, start and end arrays
  DefineShowers 'He4_' $MDL
  BuildAndSubmit
}
# **********************************************************************
 
function CosmicRay()
#********************************************************************** 
#Veritas CR (Protons and Helium)
#********************************************************************** 
{
  echo Cosmic Ray: $parspec 
  echo Protons: $protonParspec
  echo Helium4: $he4Parspec     
  #Load up the energy start and end arrays and copy over to particular
  #arrays for CR
  DefineShowers 'P' $MDL
 
  for key in "${!energy[@]}"; do
    pEnergy["$key"]="${energy["$key"]}"
  done
  for key in "${!start[@]}"; do
    pStart["$key"]="${start["$key"]}"
  done
  for key in "${!end[@]}"; do
    pEnd["$key"]="${end["$key"]}"
  done

  DefineShowers 'He4_' $MDL

  for key in "${!energy[@]}"; do
    he4Energy["$key"]="${energy["$key"]}"
  done
  for key in "${!start[@]}"; do
    he4Start["$key"]="${start["$key"]}"
  done
  for key in "${!end[@]}"; do
    he4End["$key"]="${end["$key"]}"
  done

  BuildAndSubmit
}
#***************************************************************************

function Gammas()
#**********************************************************************
#Gammas
#**********************************************************************
{
 echo Gammas: $parspec

 #Veritas Set1/ksaom/kasall
 #Whipple Set1/kasaom/kasall starts at 84 GeV
 
 #Defines energy, start and end arrays
 DefineShowers 'G' $MDL        

 BuildAndSubmit
}
#**********************************************************************

function Electrons()
#**********************************************************************
#Electrons
#**********************************************************************
{
    echo Electrons: $parspec

 Veritas Set1/ksaom/kasall
 Whipple Set1/kasaom/kasall starts at 84 GeV
 #Defines energy, start and end arrays
 DefineShowers 'E' $MDL
 BuildAndSubmit
}
#**********************************************************************

function BuildAndSubmit()
#########################################################################
# Generaic srcipt builing calling function
#########################################################################
{
  if [ ${jobSpec:2:2} = "CR" ]; then      #CosmicRay (P and He4_)
   #**********************************************************************
   #Submit in reverse order so the longest start first.
   #**********************************************************************
     let iEntryEnd=$iPEntryEnd
     if test $iPEntryEnd -lt $iHe4EntryEnd 
       then
        let iEntryEnd=$iHe4EntryEnd
     fi
     let iEntryStart=$iPEntryStart
     if test $iPEntryStart -gt $iHe4EntryStart 
       then
        let iEntryStart=$iHe4EntryStart
     fi
     #Reverse order (prefered)
     let j=$iEntryEnd
     while test $j -ge $iEntryStart
       do
	if [ $j -le $iPEntryEnd ] && [ $j -ge $iPEntryStart ];
         then 
          parspec=$protonParspec               
          datadir=$protonDatadir
          start[$j]=${pStart[$j]}
          end[$j]=${pEnd[$j]}
          energy[$j]=${pEnergy[$j]}
          echo $j ${pStart[$j]} ${start[$j]}
          if [ -n "$BYNODE" ]; then
	    BuildAndSubmitByNode $j	
	  else
            if test $j -le 19
             then
              BuildAndSubmitJobs $j 
	     else
	      BuildAndSubmitJobsSingly $j
            fi
          fi      
        fi
        if [ $j -le $iHe4EntryEnd ] && [ $j -ge $iHe4EntryStart ]; 
         then 
          parspec=$he4Parspec
          datadir=$he4Datadir
          start[$j]=${he4Start[$j]}
          end[$j]=${he4End[$j]}
          energy[$j]=${he4Energy[$j]}
       
          if [ -n "$BYNODE" ]; then
	    BuildAndSubmitByNode $j	
	  else
            if test $j -le 19
             then
              BuildAndSubmitJobs $j 
	     else
	      BuildAndSubmitJobsSingly $j
            fi
          fi
        fi
        let j=j-1		
       done
   
$ **************************************************************************
  else     #P or He4_ or E or G
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************
    let j=$iEntryEnd
    while test $j -ge $iEntryStart
      do	
        if [ -n "$BYNODE" ]; then
	  BuildAndSubmitByNode $j	
	else
          if test $j -le 19
           then
            BuildAndSubmitJobs $j 
          else
 	    BuildAndSubmitJobsSingly $j
          fi
        fi
        let j=j-1		
      done
  fi

  if [ -n "$BYNODE" ]; then	
    if [  "$JobsInPBSScript" != "0" ]; then
       ######################################################
       #We are  done. Finsh up and submit or add to list as needed
       ######################################################
	
       echo "wait"                     >>$sgeFile    
       CompleteAndSubmit $sgeFile $eGev $i
    fi
  fi
}
#**********************************************************************

function BuildSgeFilePBSCmds()
##########################################################################
# Adds PBS or SBATCH commands to "pbs" files to be submitted
# $1: This scipts name of output "pbs" file
####################################################################
{
 local sgeFile=$1
 echo "#"!/bin/bash -l                 >$sgeFile
 if [ -n "$PURDUE" ]; then
   let E=${eGeV%%.*}
   if [ "$E" -gt "20000" ]; then
     echo "#"$PBSCMD $QUEUEPHYSICS    >>$sgeFile
     echo "#"$PBSCMD $WALLTIMEPHYSICS >>$sgeFile
   else
     echo "#"$PBSCMD $QUEUESTANDBY    >>$sgeFile
     echo "#"$PBSCMD $WALLTIMESTANDBY >>$sgeFile
   fi
   echo module load gcc/4.7.2         >>$sgeFile
   echo source /etc/profile           >>$sgeFile
   echo lcl=$$PBSCMD_O_WORKDIR        >>$sgeFile
 else
   echo "#"$PBSCMD $WALLTIME          >>$sgeFile
   echo "#"$PBSCMD $QUEUE             >>$sgeFile
   if [ -n "$CORI" ]; then
     #echo "#"$PBSCMD -ccm             >>$sgeFile
     echo "#"$PBSCMD -N 1             >>$sgeFile
     echo "#"$PBSCMD -n 1             >>$sgeFile
   else
     echo "#"$PBSCMD -l $MEMREQUEST   >>$sgeFile
   fi
 fi
}
#########################################################################

function BuildSgeFileBashCmds()
##########################################################################
# Adds Batch commands to "pbs" files to be submitted
# $1: This scipts name of output "pbs" file
####################################################################
{
  sgeFile=$1
  if [ -n "$PURDUE" ]; then
    echo module load gcc/4.7.2                >>$sgeFile
    echo source /etc/profile                  >>$sgeFile
    echo lcl=$$PBSCMD_O_WORKDIR               >>$sgeFile
  fi
  echo cd $lcl                                >>$sgeFile
}
#########################################################################


function CompleteAndSubmit()
{
  sgeFile=$1
  eGev=$2
  i=$3

  chmod 700 $sgeFile
  if [ -n "$QsubFileNameList" ]; then
    echo 'echo Done >'$sgeFile'.Done'                    >>$sgeFile
    echo $sgeFile >>$QsubFileNameList
  else
    $QSUB -e k$eGeV'd'$i$parspec.err -o k$eGeV'd'$i$pr.log $sgeFile 
  fi
}
###########################################################################



function BuildAndSubmitJobs
#**********************************************************************
# Cause  cluster jobs to be submitted.
# This is the "all showers of one energy in sequence on one core"
# This is a standard way to submit jobs
#**********************************************************************
{
 local pr=$parspec
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 local eGeV=${energy[$1]}     
 echo Entry:  $pr $eGeV $showerStart $showerEnd

 sgeFile=$lcl'/K'$eGeV$pr.pbs
 BuildSgeFilePBSCmds   $sgeFile
 BuildSgeFileBashCmds  $sgeFile

 echo $ksScript $eGeV $pr $showerStart  \\   >>$sgeFile
 echo $showerEnd $datadir $workingDir   \\   >>$sgeFile
 echo ">>"$lcl"/ksProduction_"$eGeV$pr".log" >>$sgeFile

 CompleteAndSubmit $sgeFile $eGev $showerStart
}
#########################################################################

function BuildAndSubmitJobsSingly 
#**********************************************************************
# Cause serial jobs to be submitted.
# This version submits 1 job per shower. 
# This is standard way to submit
#**********************************************************************
{
 pr=$parspec
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}     

 echo Entry:  $pr $eGeV $showerStart $showerEnd

 let i=showerStart
 while test $i -le $showerEnd
  do
   sgeFile=$lcl'/K'$eGeV'd'$i$pr.pbs
   BuildSgeFilePBSCmds  $sgeFile
   BuildSgeFileBashCmds $sgeFile

   echo $ksScript $eGeV $pr $i $i $datadir $workingDir \\ >>$sgeFile
   echo ">>"$lcl"/ksProduction_"$eGeV'd'$i$pr".log"       >>$sgeFile

   CompleteAndSubmit $sgeFile $eGev $i
   let i=i+1
  done
}
# **********************************************************************

function BuildAndSubmitByNode()
###############################################################
# Just fill up a node script. AddJobForByNodeSubmission does all the work
# we just have to pass it the particulars. This looks very much like the 
# BuildAndSubmitJobsSingly function
#################################################################
{
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}     

 echo Entry:  $pr $eGeV $showerStart $showerEnd

 let i=$showerStart
 while test $i -le $showerEnd
  do
    AddJobForByNodeSubmission $i $eGev
    let i=i+1
  done
}
#########################################################################



function AddJobForByNodeSubmission()
#**********************************************************************
# Cause cluster jobs to be submitted in groups 
# of $JobsPerNode on wholely owned nodes.
#**********************************************************************
{
  pr=$parspec
  i=$1
  eGev=$2
  
  #################################################################
  # See if this is the start of a scriptWe accumulate jobs until
  # we have JobsPerNode.
  # ###############################################################
  if [ ! -n "$JobsInPBSScript" ] || [ "$JobsInPBSScript" = '0' ]; then
    #################################
    # Create next pbs script
    #################################
    GetUniqueNumber
    sgeFile=$lcl'/K'$pr$UNIQUE'.pbs'
    BuildSgeFilePBSCmds  $sgeFile "ByNode"
    BuildSgeFileBashCmds $sgeFile "ByNode"
    let JobsInPBSScript=0
    if [ -n "$CORI" ] && [ -n "$BYNODE" ]; then
      sed '/'$PBSCMD' -n'/s/'-n 1/-n 0/g' <$sgeFile  >tmp1
      mv tmp1 $sgeFile
    fi
  fi
  ##################################################################
  # Add this shower task to pbs file. Singly for now: Note the "+"
  # and the "wait" below, necessa=y for full node submission
  ##################################################################
  echo debug: $sgeFile $i
  echo $ksScript $eGeV $pr $i $i $datadir $workingDir  \\ >>$sgeFile
  echo ">>"$lcl"/ksProduction_"$eGeV'd'$i$pr".log +"      >>$sgeFile
   
  let NumJobsOld=$JobsInPBSScript 
  let JobsInPBSScript=$JobsInPBSScript+1

  ###################################################################
  #We need to keep the number of tasks in the SBATCH or PBS comand updated
  if [ -n "$CORI" ] && [ -n "$BYNODE" ]; then
    sed '/'$PBSCMD' -n'/s/'-n '$NumJobsOld'/-n '$JobsInPBSScript'/g' <$sgeFile  >tmp1 
    mv tmp1 $sgeFile
  fi

  ################################
  # See if this pbs file is done
  ################################
  if [ "$JobsInPBSScript" = "$JOBSPERNODE" ]; then 
    #Its full. Finsh up and submit or add to list as needed
    echo "wait"                     >>$sgeFile    
    CompleteAndSubmit $sgeFile $eGev $i
    let JobsInPBSScript=0 
  fi
}
#####################################################################


#*************************************************************
#Start of main script.
#*************************************************************
lcl="$PWD"

#Flag for using reduced showers for MDl CR stuff. Will be not defined for normal use.
MDL=$9

##################
# Bring in GenerateVBFName and GetUniqueNumber  functions
##################
if [ ! -e UtilityFunctions.scr ]; then
    cp $KASCADEBASE/scripts/UtilityFunctions.scr ./
fi
source UtilityFunctions.scr

host=$(hostname)
echo host: $host

hostString=${host:0:6}
if test  "$hostString" = "edison"  #Are we running on Edison
then
  EDISON=enabled
  QSUB='qsub.serial -V'
  PBSCMD='PBS'
  QUEUE='-q serial'
  WALLTIME='-l walltime=20:00:00'
  MEMREQUEST='vmem=4GB'
  echo ***Edison Cluster***
fi

hostString=${host:0:4}
if test  "$hostString" = "cori"  #Are we running on cori
then
  CORI=enabled
  QSUB='sbatch'
  PBSCMD='SBATCH'
  BYNODE=enabled
  if [ -n "$BYNODE" ]; then
    let JOBSPERNODE=32
    QUEUE='-p regular'
  else
    QUEUE='-p shared'
  fi
  WALLTIME='-t 11:00:00'
  echo ***Cori Phase 1 Cluster***
fi


hostString=${host:0:6}
if test  "$hostString" = "hansen"  #Are we running on Hansen
then
  HANSEN=enabled
  QSUB='qsub -V'
  PBSCMD='PBS'
  QUEUEPHYSICS='-q physics'
  WALLTIMEPHYSICS='-l walltime=20:00:00'
  QUEUESTANDBY='-q standby'
  WALLTIMESTANDBY='-l walltime=04:00:00'
  QUEUE=$QUEUEPHYSICS
fi

hostString=${host:0:6}
if test  "$hostString" = "coates"  #Are we running on COATES
then
SBATCH  COATES=enabled
  QSUB='qsub -V'
  PBSCMD='PBS'
  QUEUESTANDBY='-q standby'
  QUEUE=$QUEUEPHYSICS
  WALLTIME='-l walltime=20:00:00'
  #WALLTIME='-l walltime=04:00:00'
  MEMREQUEST='mem=8GB'
fi

hostString=${host:0:5}
if test  "$hostString" = "conte"  #Are we running on CONTE
then
  CONTE=enabled
  QSUB='qsub -V'
  PBSCMD='PBS'
  QUEUEPHYSICS='-q physics'
  WALLTIMEPHYSICS='-l walltime=20:00:00'
  QUEUESTANDBY='-q standby'
  WALLTIMESTANDBY='-l walltime=04:00:00'
  QUEUE=$QUEUEPHYSICS
  MEMREQUEST='mem=8GB'
fi

hostString=${host:0:6}
if test  "$hostString" = "flogin"  #Are we running on ANL Fusion
then
  FUSION=enabled
  QSUB='qsub -V'
  PBSCMD='PBS'
  # queue is determined by pbs.
  WALLTIME='-l walltime=30:00:00'
fi

hostString=${host:0:4}
if test  "$hostString" = "isis"  #Are we running on ISIS
then
  ISIS=enabled
fi

if [ -n "$HANSEN" ] || [ -n "$CONTE" ] || [ -n "$COATES" ] ; then
  PURDUE=enabled
fi
if [ -n "$EDISON" ] || [ -n "$CORI" ] || [ -n "$FUSION" ]; then
  NERSCorARGN=enabled
fi	
 


#script directory
sdr=$KASCADEBASE"/scripts"
ksscpt=$2

#Check to see if the user specified the script with the .scr extention
ksscpt=${ksscpt%.scr}

            #Assume local copy of script
kssc=${ksscpt##*/}
if test "$kssc" = "$ksscpt"
then
  ksScript=$lcl'/'$kssc'.scr' #ksall: Makes seg,pe,pes,te files. Keeps te files
                          #ksaom: Makes .root  files from te files(depreciated)
                           #ksaomVBF: Makes .vbf files from te files
                          #ksarraytriggerVBF: Makes array  .vbf files
                          #ksallVBF:Does everything from ksKascade to 
                          #         ksArrayTrigger
else
    ksScript=$ksscpt'.scr'
fi
echo ksScript: $ksScript
echo kssc: $kssc

let lastJob=8
if [ "$kssc" = "ksMissingVBF" ] || [ "$kssc" = "ksMissingTE" ]; then
    let lastJob=1
fi
#####################################################################

if [ -n "$4" ]; then   #See if optional  qsub file namer list file is defined
  QsubFileNameList=$4  #if so we will not submit jobs to the cluster but
fi                     # let the calling program do that by using this file

#######################################

#ISIS
if [ -n "$ISIS" ]; then
    if test ${lcl:1:4} = "disk"
    then
       dataDirBase=${lcl:0:6}'/simulations'
    else
       dataDirBase=/simulations
    fi
    mkdir -vp $dataDirBase
    workingDir=$lcl

    let jobNum=1
    while test $jobNum -le $lastJob
    do
	    #define job script name
	JobScript=$lcl'/js'$jobNum'_'$1'.scr'
	    #Initialze the script files
	echo echo Starting $JobScript >$JobScript
    jobNum=$((jobNum+1))
    done
fi



if [ -n "$EDISON" ]; then
    dataDirBase=$SCRATCH'/simulations'
    echo Edison Data Dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$SCRATCH
fi

if [ -n "$CORI" ]; then
    dataDirBase=$SCRATCH'/simulations'
    echo Cori Data Dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$SCRATCH
fi

if [ -n "$HANSEN" ]; then
    dataDirBase=$SCRATCH'/simulations'
    echo Hansen Data dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$SCRATCH                     
    JobsPerNode=48
    NumCores=48
    if [ "$3" = "Sort" ]; then
	Sort=enabled
        echo Hansen:Sort: $Sort
    fi
fi

if [ -n "$CONTE" ]; then
    dataDirBase=$SCRATCH'/simulations'
    echo Conte Data dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$SCRATCH                     
    JobsPerNode=32
    NumCores=32
    if [ "$3" = "Sort" ]; then
	Sort=enabled
        echo Conte:Sort: $Sort
    fi
fi

if [ -n "$COATES" ]; then
    dataDirBase=$SCRATCH'/simulations'
    echo Coates Data dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$SCRATCH
fi

if [ -n "$FUSION" ]; then
    dataDirBase=$SCRATCH'/simulations'
    echo Fusion Data dir: $dataDirBase
    mkdir -vp $dataDirBase  
    workingDir='/scratch'                   #Use local scratch disk on nodes.
fi

user=$USER

#Fuctions specify which nodes are to be used ("on" or "off")
#Funtions also specify the energy and specify the starting and ending shower 
#IDs.
#See bottom for numbers and energies for gammas,protons and he4

#******************************************************************************
# Set up arrays for node submission and submit
#*****************************************************************************
let pspecset=0
maxMem=240MB
jobSpec=$1


if [ ${jobSpec:1:1} = "W" ]; then
   dataDirBase=$dataDirBase'/whipple'
   mkdir -vp $dataDirBase
fi

if [ ${jobSpec:1:1} = "N" ] || [ ${jobSpec:1:1} = "U" ] || 
   [ ${jobSpec:1:1} = "O" ]; then
    dataDirBase=$dataDirBase'/veritas'
    mkdir -vp $dataDirBase
fi

if [ ${jobSpec:2:2} = "CR" ]; then      #CosmicRay (P and He4_)
                                        
    AtmSpec=${jobSpec:0:1}             #gets S(for summer) from  
                                        #SWCR20DegN0.5Deg50mv1234M2
    TelSpec=${jobSpec:1:1}              #gets W from CWCR20DegN0.5Deg50mv1234M2
    spec=${jobSpec#*CR}                 #gets 20DegN0.3Deg50mv1234M2 from 
                                        #WWCR20DegN0.3Deg50mv1234M2

    if [ -n "$NERSCorARGN" ] || [ -n "$PURDUE" ]; then
      #Protons
       protonParspec=$AtmSpec$TelSpec'P'$spec
       protonDatadir="$dataDirBase/protons"
       echo CR:Proton Dir: $protonDatadir
       mkdir -vp $protonDatadir

#Helium4
       he4Parspec=$AtmSpec$TelSpec'He4_'$spec
       he4Datadir="$dataDirBase/he4"
       echo CR:He4 Dir: $he4Datadir
       mkdir -vp  $he4Datadir
 
       if [ -n "$5" ]; then
	let iPEntryStart=$5
       else
        let iPEntryStart=1
       fi

       if [ -n "$6" ]; then
	let iPEntryEnd=$6
       else
        let iPEntryEnd=45
       fi

       if [ -n "$7" ]; then
	let iHe4EntryStart=$7
       else
        let iHe4EntryStart=5
       fi

       if [ -n "$8" ]; then
	let iHe4EntryEnd=$8
       else
        let iHe4EntryEnd=45
       fi
      
       CosmicRay
      
       let pspecset=1;
    else
       parspec=$AtmSpec$TelSpec'P'$spec   #gives SVP20DegN0.3Deg50mv1234M2ABCD
       datadir="$dataDirBase/protons"     #from SVCR20DegN0.3Deg50mv1234M2ABCD
       mkdir -vp $datadir
       Protons

       datadir="$dataDirBase/he4"
       parspec=$AtmSpec$TelSpec'He4_'$spec
       mkdir -vp $datadir
       Helium4
       let pspecset=1;
    fi
fi

if [ ${jobSpec:2:1} = "E" ]; then 
    parspec=$1 
    datadir="$dataDirBase/electrons"
    mkdir -vp $datadir
    if [ -n "$5" ]; then
	let iEntryStart=$5
    else
        let iEntryStart=1
    fi
    if [ -n "$6" ]; then
	let iEntryEnd=$6
    else
        let iEntryEnd=45
    fi
    Electrons
    let pspecset=1;
fi

if [ ${jobSpec:2:1} = "P" ] ; then 
    parspec=$1 
    datadir="$dataDirBase/protons"
    mkdir -vp $datadir
    if [ -n "$5" ]; then
      let iEntryStart=$5
    else
      let iEntryStart=1
    fi

    if [ -n "$6" ]; then
      let iEntryEnd=$6
    else
      let iEntryEnd=45
    fi
    Protons
    let pspecset=1;
fi

if [ ${jobSpec:2:4} = "He4_" ] ; then 
    parspec=$1 
    datadir="$dataDirBase/he4"
    mkdir -vp $datadir
    if [ -n "$5" ]; then
      let iEntryStart=$5
    else
      let iEntryStart=5
    fi

    if [ -n "$6" ]; then
      let iEntryEnd=$6
    else
      let iEntryEnd=45
    fi
    Helium4
    let pspecset=1;
fi

if [ ${jobSpec:2:1} = "G" ]; then
    parspec=$1
    datadir="$dataDirBase/gammas"
    mkdir -vp $datadir 
    if [ -n "$5" ]; then
	let iEntryStart=$5
    else
        let iEntryStart=1
    fi
    if [ -n "$6" ]; then
	let iEntryEnd=$6
    else
        let iEntryEnd=45
    fi
    Gammas
    let pspecset=1;
fi

echo datadir $datadir

if [ $pspecset -ne 1 ]; then
    echo No such Particle spec: $1
    exit
fi

#ISIS
if [ -n "$ISIS" ]; then
   
    let jobNum=1
    while test $jobNum -le $lastJob
    do
	    #define job script name
	JobScript=$lcl'/js'$jobNum'_'$jobSpec'.scr'
	if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	    JobScriptLog=$lcl'/js'$jobNum'_'$jobSpec'.log'
	    #Initialze the script files
	    chmod 777 $JobScript
	    $JobScript  >$JobScriptLog &
	else
	    #Initialze the script files
	    chmod 777 $JobScript
	    $JobScript 
	fi
    jobNum=$((jobNum+1))
    done
fi


###########################################################################
#Arguments for ksScript
#$1 primary Energy in GeV (integer only)
#$2 Shower type specification string (To be included in config file names and 
#                              in shower names:Like P1W,G1W, He4_1W, G20N0.3V)
#$3 Lowest flie id
#$4 Highest file id.
#$5 data disk directory.(Where output Te/root  files go, cannot be blank!!!)
#############################################################################


##################################################
## All the following for reference only
##################################################
