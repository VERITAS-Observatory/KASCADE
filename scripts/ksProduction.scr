#	!/bin/bash
#$0 ./kas02.scr
#$1 Gets passed directly to ksallVBF.scr. Used here to specify what particle 
#   types are to be processed. (G,P,He4_ or CR(causes P and He4_ , Or E for electrons)
#   For ksallVBF (minimum:up to kasallVBF.scr calling ksTrigger:
#     Atm-Telescope-Type-direction-threshold-arraytrigger specification 
#     designation: 
#     like: WWP1Deg50mv1234M2, CWHe4_1Deg50mv1234M2, SWG1Deg50mv1234M2,
#     WVG1DegN0.5Deg50mv1234M2.  
#     Giveing a Type code of 'WWCR1Deg50mv1234M2 will cause 
#     both WWP1Deg50mv1234M2  and WWHe4_1Deg50mv1234M2 to be  run
#   For ksallVBF through ksArrayTrigger append the telescope designations: 
#     Like WVG20Deg2D50mv1234M2ABCD
#$2 has which script to run:  ksallVBF.scr
#        ksallVBF.scr is all Singing all dancing: ksKascade to ksArrayTrigger
#*****************************************************************
#Functions to define thigs for various particle specs

function Protons()
#**********************************************************************
#Veritas/Whipple Protons
#**********************************************************************
{
    echo Protons: $parspec
    WALLTIME=75:00:00
#Veritas/Whipple set1/ksaom/kasall
######      1    2    3    4    5    6    7    8    9    10  11    12  13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    44    
energy=([1]=20   23.9 28.6 34.2 40.9 48.9 58.5 69.9 83.6 100 119.6 143 171 204.5 244.5 292.4 350  418 500 598 715 855 1022 1223 1462 1748 2091 2500 2990 3575 4275 5112 6113 7310 8741 10453 12500 14948 17875 21375 25560 30565 43707 52265 ) 
 start=([1]=1    1    1    1    1    1    1    1    1    1   1     1   1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 ) 
   end=([1]=1382 1007 734  535  390  284  207  151  110  80  59    43  31  23    17    12    10   10  10  10  10  10  10   10   10   10   10   10   10   10   10   10   10   10   10   10    10    10    10    10    10    5     5     5 )

#10%
#   end=([1]=139  101  74   54   39   29   21   16   11   8   6     5   4   3     2     2     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 )


#VeritasSet2
#       energy=([1]=21.9 26.2 31.3 37.4 44.7 53.5 64.0 76.5 91.5 109.4 130.8 156.4 187 223.6 267.4 319.8 382  457 547 654 782 935 1118 1337 1599 1912 2286 2734 3269 3909 4675 5590 6685 7994 9559 11431 13669 16346 19546 23374 27951 33424)
#        start=([1]=1    1    1    1    1    1    1    1    1    1     1     1     1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1)
#          end=([1]=1180 860  627  457  333  243  177  129  94   69    50    37    27  20    15    11    8    6   5   5   5   5   5    5    5    5    5    5    5    5    5    5    5    5    5    5     5     5     5     5     5     5)

    if [ -n "$ISIS" ]; then
      if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
#ksaomVBF ~12hr.
	BuildIsisScriptList 1 1   9
	BuildIsisScriptList 2 10 18 
	BuildIsisScriptList 3 19 24
	BuildIsisScriptList 4 25 30
	BuildIsisScriptList 2 31 31             #for balance
	BuildIsisScriptList 5 32 33
	BuildIsisScriptList 6 34 36

#	BuildIsisScriptList 1 1 10
#	BuildIsisScriptList 2 11 20
#	BuildIsisScriptList 3 21 25
#	BuildIsisScriptList 4 26 32
#	BuildIsisScriptList 5 33 37
#	BuildIsisScriptList 6 38 41
#	BuildIsisScriptList 1 42 42	        #For balance

#For High ksall ~ 5hrs
#           BuildIsisScriptList 1 35 35
#	    BuildIsisScriptList 2 36 36
#	    BuildIsisScriptList 3 37 37
#	    BuildIsisScriptList 4 38 38
#	    BuildIsisScriptList 5 39 39
#	    BuildIsisScriptList 6 40 40
#	    BuildIsisScriptList 7 41 41
#	    BuildIsisScriptList 8 42 42
 
      else
	    BuildIsisScriptList 1 1  42
      fi
    fi



#PDSF
   if [ -n "$PDSF" ]; then
     #**********************************************************************
     #Submit in reverse order so the longest start first.
     #**********************************************************************
	    let iEntryStart=1
	    let iEntryEnd=36	
#	    let iEntryEnd=39
#	    let iEntryEnd=36          #10% end


	    let j=$iEntryEnd
            while test $j -ge $iEntryStart
            do	
	       BuildAndSubmitPDSFJobArray $j 
#	       BuildAndSubmitPDSFJobs $j 
	       j=$((j-1))		
	    done
    fi
#CARVER
   if [ -n "$CARVER" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************

#           let iEntryStart=1
#           let iEntryEnd=44
           let iEntryStart=23
           let iEntryEnd=23

#Reverse order (prefered)
	   let j=$iEntryEnd
           while test $j -ge $iEntryStart
            do	
               if test $j -le 19
                then
                  BuildAndSubmitCarverJobs $j 
	        else
                  #BuildAndSubmitLargeCarverJobs $j
                  #BuildAndSubmitCarverJobs $j 
	          BuildAndSubmitCarverJobsSingly $j
               fi
               let j=j-1		
            done

#normal order
#	   let j=$iEntryStart
#           while test $j -le $iEntryEnd
#            do	
#               BuildAndSubmitCarverJobs $j 
#	       #BuildAndSubmitLargeCarverJobs $j
#	       j=$((j+1))		
#            done

    fi
#********************************************************************************

#HANSEN
   if [ -n "$HANSEN" ]; then
     #**********************************************************************
     #Submit in reverse order so the longest start first.
     #**********************************************************************
     let iEntryStart=1
     let iEntryEnd=44

     #Reverse order (prefered)
     let j=$iEntryEnd
     while test $j -ge $iEntryStart
       do	
         if test $j -le 19
         then
           BuildAndSubmitHansenJobs $j 
	 else
	   BuildAndSubmitHansenJobsSingly $j
         fi
         let j=j-1		
       done
   fi


}
#**********************************************************************


function Helium4()
#**********************************************************************
#Veritas  and whipple Helium4
#**********************************************************************
{
    echo Helium4: $parspec
    WALLTIME=50:00:00

#Veritas/Whipple Set1/ksaom/kasall
######      1    2    3    4    5    6    7    8    9    10  11    12  13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    44    
energy=([1]=20   23.9 28.6 34.2 40.9 48.9 58.5 69.9 83.6 100 119.6 143 171 204.5 244.5 292.4 350  418 500 598 715 855 1022 1223 1462 1748 2091 2500 2990 3575 4275 5112 6113 7310 8741 10453 12500 14948 17875 21375 25560 30565 43707 52265 ) 
 start=([1]=1    1    1    1    1    1    1    1    1    1   1     1   1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 ) 
#  end=([1]=519  387  289  215  161  120  90   67   50   37  28    21  16  12    10    10    10   10  10  10  10  10  10   10   10   10   10   10   10   10   10   10   10   10   10   10    10    10    10    10    10    5     5     5 )

#10%
   end=([1]=52   39   29   22   17   12   9    7    5    4   3     3   2   2     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 )  

#VeritasSet2
#       energy=([1]=21.9 26.2 31.3 37.4 44.7 53.5 64.0 76.5 91.5 109.4 130.8 156.4 187 223.6 267.4 319.8 382  457 547 654 782 935 1118 1337 1599 1912 2286 2734 3269 3909 4675 5590 6685 7994 9559 11431 13669 16346 19546 23374 27951 33424)
#        start=([1]=1    1    1    1    1    1    1    1    1    1     1     1     1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1)
#          end=([1]=448  334  249  186  139  104  78   58   43   32    24    18    14  10    8     6     5    5   5   5   5   5   5    5    5    5    5    5    5    5    5    5    5    5    5    5     5     5     5     5     5     5)

    if [ -n "$ISIS" ]; then
      if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then

#set 1 kasaomVBF ~5 hr.
	BuildIsisScriptList 1 6  25
	BuildIsisScriptList 2 26 30
	BuildIsisScriptList 3 31 33
	BuildIsisScriptList 4 34 34
	BuildIsisScriptList 5 35 36
	BuildIsisScriptList 6 36 36


#	BuildIsisScriptList 1 6  20
#	BuildIsisScriptList 2 21 30
#	BuildIsisScriptList 3 31 36
#	BuildIsisScriptList 4 37 39
#	BuildIsisScriptList 5 40 40
#    	BuildIsisScriptList 3 41 41     #Balance
#	BuildIsisScriptList 2 42 42     #balance

#For High ksall ~ 5hrs
#           BuildIsisScriptList 1 35 35
#	    BuildIsisScriptList 2 36 36
#	    BuildIsisScriptList 3 37 37
#	    BuildIsisScriptList 4 38 38
#	    BuildIsisScriptList 5 39 39
#	    BuildIsisScriptList 6 40 40
#	    BuildIsisScriptList 7 41 41
#	    BuildIsisScriptList 8 42 42

      else
	BuildIsisScriptList 1 1 42
      fi
    fi


#PDSF
   if [ -n "$PDSF" ]; then
            #**********************************************************************
            #Submit in reverse order so the longest start first.
            #**********************************************************************
	    let iEntryStart=6   #Normal start
#	    let iEntryEnd=30
#	    let iEntryStart=1
#	    let iEntryEnd=8
#	    let iEntryEnd=42
	    let iEntryEnd=36             #10%end

	    let j=$iEntryEnd
            while test $j -ge $iEntryStart
            do	
	       BuildAndSubmitPDSFJobArray $j
#	       BuildAndSubmitPDSFJobs $j
	       j=$((j-1))		
            done
    fi
#CARVER
   if [ -n "$CARVER" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************

           let iEntryStart=1
           let iEntryEnd=44


#Reverse order (prefered)
	   let j=$iEntryEnd
           while test $j -ge $iEntryStart
            do	
               if test $j -le 19
                then
                  BuildAndSubmitCarverJobs $j 
	        else
                  #BuildAndSubmitLargeCarverJobs $j
                  #BuildAndSubmitCarverJobs $j 
	          BuildAndSubmitCarverJobsSingly $j
               fi
               let j=j-1		
            done

#normal order
#	   let j=$iEntryStart
#           while test $j -le $iEntryEnd
#            do	
#               BuildAndSubmitCarverJobs $j 
#	       #BuildAndSubmitLargeCarverJobs $j
#	       j=$((j+1))		
#            done

    fi
#HANSEN
   if [ -n "$HANSEN" ]; then
     #**********************************************************************
     #Submit in reverse order so the longest start first.
     #**********************************************************************
     let iEntryStart=1
     let iEntryEnd=44

     #Reverse order (prefered)
     let j=$iEntryEnd
     while test $j -ge $iEntryStart
       do	
         if test $j -le 19 
         then
           BuildAndSubmitHansenJobs $j 
	 else
	   BuildAndSubmitHansenJobsSingly $j
         fi
         let j=j-1		
       done
   fi
#********************************************************************************
}
#**********************************************************************


function CosmicRay()
#********************************************************************** 
#Veritas CR (Protons and Helium)
#********************************************************************** 
{
    echo Cosmic Ray: $parspec 
    echo Protons: $protonParspec
    echo Helium4: $he4Parspec     
    WALLTIME=75:00:00
#Veritas/Whipple Set1/ksaom/kasall
######       1    2    3    4    5    6    7    8    9    10  11    12  13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    44    
pEnergy=([1]=20   23.9 28.6 34.2 40.9 48.9 58.5 69.9 83.6 100 119.6 143 171 204.5 244.5 292.4 350  418 500 598 715 855 1022 1223 1462 1748 2091 2500 2990 3575 4275 5112 6113 7310 8741 10453 12500 14948 17875 21375 25560 30565 43707 52265 ) 
 pStart=([1]=1    1    1    1    1    1    1    1    1    1   1     1   1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 ) 
   pEnd=([1]=1382 1007 734  535  390  284  207  151  110  80  59    43  31  23    17    12    10   10  10  10  10  10  10   10   10   10   10   10   10   10   10   10   10   10   10   10    10    10    10    10    10    5     5     5 )

#10%
#   pEnd=([1]=139  101  74   54   39   29   21   16   11   8   6     5   4   3     2     2     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 )

######         1    2    3    4    5    6    7    8    9    10  11    12  13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    44    
he4Energy=([1]=20   23.9 28.6 34.2 40.9 48.9 58.5 69.9 83.6 100 119.6 143 171 204.5 244.5 292.4 350  418 500 598 715 855 1022 1223 1462 1748 2091 2500 2990 3575 4275 5112 6113 7310 8741 10453 12500 14948 17875 21375 25560 30565 43707 52265 ) 
 he4Start=([1]=1    1    1    1    1    1    1    1    1    1   1     1   1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 ) 
   he4End=([1]=519  387  289  215  161  120  90   67   50   37  28    21  16  12    10    10    10   10  10  10  10  10  10   10   10   10   10   10   10   10   10   10   10   10   10   10    10    10    10    10    10    5     5     5 )

#10%
#   he4End=([1]=52   39   29   22   17   12   9    7    5    4   3     3   2   2     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     1     1     1 )  


#CARVER
   if [ -n "$CARVER" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************
      let iPEntryStart=1
      let iHe4EntryStart=5  #Normal start for helium
      let iPEntryEnd=42
      let iHe4EntryEnd=42          #36 is 10% end

      let iEntryEnd=$iPEntryEnd
      if test $iPEntryEnd -lt $iHe4EntryEnd 
       then
        let iEntryEnd=$iHe4EntryEnd
      fi
      let iEntryStart=$iPEntryStart
      if test $iPEntryStart -gt $iHe4EntryStart 
       then
        let iEntryStart=$iHe4EntryStart
      fi
#Reverse order (prefered)
      let j=$iEntryEnd
      while test $j -ge $iEntryStart
       do
	if [ $j -le $iPEntryEnd ] && [ $j -ge $iPEntryStart ];
         then 
          parspec=$protonParspec               
          datadir=$protonDatadir
          start[$j]=${pStart[$j]}
          end[$j]=${pEnd[$j]}
          energy[$j]=${pEnergy[$j]}
       
          if test $j -le 19
           then
            BuildAndSubmitCarverJobs $j 
	   else
            #BuildAndSubmitLargeCarverJobs $j
            #BuildAndSubmitCarverJobs $j 
	    BuildAndSubmitCarverJobsSingly $j
          fi
 	fi      
          
        if [ $j -le $iHe4EntryEnd ] && [ $j -ge $iHe4EntryStart ]; 
         then 
          parspec=$he4Parspec
          datadir=$he4Datadir
          start[$j]=${he4Start[$j]}
          end[$j]=${he4End[$j]}
          energy[$j]=${he4Energy[$j]}
       
          if test $j -le 19
           then
            BuildAndSubmitCarverJobs $j 
	   else
            #BuildAndSubmitLargeCarverJobs $j
            #BuildAndSubmitCarverJobs $j 
	    BuildAndSubmitCarverJobsSingly $j
          fi
        fi
        let j=j-1		
       done
    fi
#********************************************************************************

#HANSEN
   if [ -n "$HANSEN" ]; then
     #**********************************************************************
     #Submit in reverse order so the longest start first.
     #**********************************************************************
     let iPEntryStart=1
     let iHe4EntryStart=6   #Normal start for helium
#     let iPEntryEnd=36
#     let iHe4EntryEnd=36          #10% end
     let iPEntryEnd=42
     let iHe4EntryEnd=42          #10% end

     let iEntryEnd=$iPEntryEnd
     if test $iPEntryEnd -lt $iHe4EntryEnd 
     then
       let iEntryEnd=$iHe4EntryEnd
     fi

     let iEntryStart=$iPEntryStart
     if test $iPEntryStart -gt $iHe4EntryStart 
     then
       let iEntryStart=$iHe4EntryStart
     fi

     #Reverse order (prefered)
     let j=$iEntryEnd
     while test $j -ge $iEntryStart
       do
	 if [ $j -le $iPEntryEnd ] && [ $j -ge $iPEntryStart ];then 
           parspec=$protonParspec               
           datadir=$protonDatadir
           start[$j]=${pStart[$j]}
           end[$j]=${pEnd[$j]}
           energy[$j]=${pEnergy[$j]}
       
           if test $j -le 19  
           then
             BuildAndSubmitHansenJobs $j 
	   else
	     BuildAndSubmitHansenJobsSingly $j
           fi
 	 fi      
          
         if [ $j -le $iHe4EntryEnd ] && [ $j -ge $iHe4EntryStart ]; then 
           parspec=$he4Parspec
           datadir=$he4Datadir
           start[$j]=${he4Start[$j]}
           end[$j]=${he4End[$j]}
           energy[$j]=${he4Energy[$j]}
       
           if test $j -le 19  
           then
             BuildAndSubmitHansenJobs $j 
	   else
	     BuildAndSubmitHansenJobsSingly $j
           fi
         fi
         let j=j-1		
      done
  fi
#********************************************************************************

}
#*********************************************************************


function Gammas()
#**********************************************************************
#Gammas
#**********************************************************************
{
    echo Gammas: $parspec
    WALLTIME=100:00:00

#Veritas Set1/ksaom/kasall
#Whipple Set1/kasaom/kasall starts at 84 GeV
######      1    2    3    4    5    6    7    8    9    10  11    12  13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    44    45    46
energy=([1]=20   23.9 28.6 34.2 40.9 48.9 58.5 69.9 83.6 100 119.6 143 171 204.5 244.5 292.4 350  418 500 598 715 855 1022 1223 1462 1748 2091 2500 2990 3575 4275 5112 6113 7310 8741 10453 12500 14948 17875 21375 25560 25560 30565 30565 43707 52265 ) 
 start=([1]=1    1    1    1    1    1    1    1    1    1   1     1   1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     11    1     11    1     1) 

#Small E-2.0
   end=([1]=1001 837  700  585  490  409  342  286  240  200 168   140 117 98    82    69    58   48  40  34  28  24  20   20   20   20   20   20   20   20   20   20   20   20   20   20    20    20    20    20    10    20    10    20    10    10 )



#Big E-2.45   end=([1]=2064 1592 1229 948  732  565  436  336  260  200 155   120 92  71    55    50    50   50  50  50  50  50  50   50   50   50   50   50   50   50   50   50   50   50   50   50    50    50    50    50    10    20    10    20)
#Small E-2.45 end=([1]=2064 1592 1229 948  732  565  436  336  260  200 155   120 92  71    55    44    34   26  20  20  20  20  20   20   20   20   20   20   20   20   20   20   20   20   20   20    20    20    20    20    10    20    10    20)


#VeritasSet2
############       1    2    3    4    5    6    7    8    9    10    11    12    13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    
#       energy=([1]=21.9 26.2 31.3 37.4 44.7 53.5 64.0 76.5 91.5 109.4 130.8 156.4 187 223.6 267.4 319.8 382  457 547 654 782 935 1118 1337 1599 1912 2286 2734 3269 3909 4675 5590 6685 7994 9559 11430 13669 16346 19546 23374 23374 27951 27951)
#        start=([1]=1    1    1    1    1    1    1    1    1    1     1     1     1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     11    1     11)
#	  end=([1]=1813 1399 1079 833  643  496  383  296  228  176   136   105   81  63    49    38    29   23  20  20  20  20  20   20   20   20   20   20   20   20   20   20   20   20   20   20    20    20    20    10    20    10    20)  
 
    if [ -n "$ISIS" ]; then
	if [ ${jobSpec:0:1} = "W" ] ; then
          if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	    BuildIsisScriptList 1 11 12
	    BuildIsisScriptList 2 13 14
	    BuildIsisScriptList 3 15 16
	    BuildIsisScriptList 4 17 18
	    BuildIsisScriptList 5 19 20
	    BuildIsisScriptList 6 21 23
	    BuildIsisScriptList 7 24 26
	    BuildIsisScriptList 8 27 28
          else
	    BuildIsisScriptList 1 1 44
          fi
	fi
	if [ ${jobSpec:0:1} = "V" ] ; then
          if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	   #For ksaomVBF ~1:20 
#             For ksallVBF: set 1 about 24 hours <=10 TeV
	    BuildIsisScriptList 1 1  4
	    BuildIsisScriptList 2 5  9
	    BuildIsisScriptList 3 10 15
	    BuildIsisScriptList 4 16 24
	    BuildIsisScriptList 5 25 32
	    BuildIsisScriptList 6 33 34
	    BuildIsisScriptList 7 35 35
	    BuildIsisScriptList 8 36 36

# High >10 TeV 48 hrs?
#	    BuildIsisScriptList 1 37  37
#	    BuildIsisScriptList 2 38  38
#	    BuildIsisScriptList 3 39  39
#	    BuildIsisScriptList 4 40  40
#	    BuildIsisScriptList 5 41  41
#	    BuildIsisScriptList 6 42  42
#	    BuildIsisScriptList 7 43  43
#	    BuildIsisScriptList 8 44  44

          else
	    BuildIsisScriptList 1 1 44
          fi
	fi
    fi


#CARVER
   if [ -n "$CARVER" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************
#           let iEntryStart=19
#           let iEntryEnd=19

           let iEntryStart=1   #498 jobs
#           let iEntryStart=41   #498jobs
#           let iEntryEnd=40
           let iEntryEnd=44

#Reverse order (prefered)
	   let j=$iEntryEnd
           while test $j -ge $iEntryStart
            do	
               if test $j -le 19
                then
                  BuildAndSubmitCarverJobs $j 
	        else
                  #BuildAndSubmitCarverJobs $j 
	          BuildAndSubmitCarverJobsSingly $j
               fi
               let j=j-1		
            done

#normal order
#	   let j=$iEntryStart
#           while test $j -le $iEntryEnd
#            do	
#               BuildAndSubmitCarverJobs $j 
#	       #BuildAndSubmitLargeCarverJobs $j
#	       j=$((j+1))		
#            done

    fi


#HANSEN
   if [ -n "$HANSEN" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************
      let iEntryStart=1
      let iEntryEnd=46

      #Reverse order (prefered)
      let j=$iEntryEnd
      while test $j -ge $iEntryStart
        do	
          if test $j -le 19  
          then
            BuildAndSubmitHansenJobs $j 
	  else
	    BuildAndSubmitHansenJobsSingly $j
          fi
          let j=j-1		
        done
    fi
#********************************************************************************


#PDSF
   if [ -n "$PDSF" ]; then
     #**********************************************************************
     #Submit in reverse order so the longest start first.
     #**********************************************************************

# *******************************************************************
#Folowing for making te.d files on PDSF with our 500 GByte limitation
#	    let iEntryStart=1      #Making te.d: First group: fits 500 Gbytes
#	    let iEntryEnd=27       #Use BuildAndSubmitPDSFJobArray
#
#	    let iEntryStart=28     #Making te.d: second group: fits 500 Gbytes
#	    let iEntryEnd=35       #Use BuildAndSubmitPDSFJobGroups @5 each
#
#	    let iEntryStart=36     #Making te.d: third group: fits 500 Gbytes
#	    let iEntryEnd=39       #Use BuildAndSubmitPDSFJobGroups @5 each
# 
#	    let iEntryStart=40     #Making te.d: third group: fits 500 Gbytes
#	    let iEntryEnd=44       #Use BuildAndSubmitPDSFJobGroups @5 each
#                   or
#	    let iEntryStart=40     #Making te.d: third groupSecond energy set: fits 500 Gbytes
#	    let iEntryEnd=43       #Use BuildAndSubmitPDSFJobGroups @5 each
# *********************************************************************

           let iEntryStart=44
	   let iEntryEnd=44

#           let iEntryStart=1
#	   let iEntryEnd=44
	    let j=$iEntryEnd
            while test $j -ge $iEntryStart
            do	
               #BuildAndSubmitPDSFJobGroups $j 5
               BuildAndSubmitPDSFJobArray $j
	       j=$((j-1))		
            done
    fi
# ********************************************

}
#********************************************************************************

function Electrons()
#**********************************************************************
#Electrons
#**********************************************************************
{
    echo Electrons: $parspec
    WALLTIME=100:00:00

#Veritas Set1/ksaom/kasall
#Whipple Set1/kasaom/kasall starts at 84 GeV
######      1    2    3    4    5    6    7    8    9    10  11    12  13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    44    45    46
energy=([1]=20   23.9 28.6 34.2 40.9 48.9 58.5 69.9 83.6 100 119.6 143 171 204.5 244.5 292.4 350  418 500 598 715 855 1022 1223 1462 1748 2091 2500 2990 3575 4275 5112 6113 7310 8741 10453 12500 14948 17875 21375 25560 25560 30565 30565 43707 52265 ) 
 start=([1]=1    1    1    1    1    1    1    1    1    1   1     1   1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     1     11    1     11    1     1) 

#Small E-2.0
   end=([1]=1001 837  700  585  490  409  342  286  240  200 168   140 117 98    82    69    58   48  40  34  28  24  20   20   20   20   20   20   20   20   20   20   20   20   20   20    20    20    20    20    10    20    10    20    10    10 )



#Big E-2.45   end=([1]=2064 1592 1229 948  732  565  436  336  260  200 155   120 92  71    55    50    50   50  50  50  50  50  50   50   50   50   50   50   50   50   50   50   50   50   50   50    50    50    50    50    10    20    10    20)
#Small E-2.45 end=([1]=2064 1592 1229 948  732  565  436  336  260  200 155   120 92  71    55    44    34   26  20  20  20  20  20   20   20   20   20   20   20   20   20   20   20   20   20   20    20    20    20    20    10    20    10    20)




#VeritasSet2
############       1    2    3    4    5    6    7    8    9    10    11    12    13  14    15    16    17   18  19  20  21  22  23   24   25   26   27   28   29   30   31   32   33   34   35   36    37    38    39    40    41    42    43    
#       energy=([1]=21.9 26.2 31.3 37.4 44.7 53.5 64.0 76.5 91.5 109.4 130.8 156.4 187 223.6 267.4 319.8 382  457 547 654 782 935 1118 1337 1599 1912 2286 2734 3269 3909 4675 5590 6685 7994 9559 11430 13669 16346 19546 23374 23374 27951 27951)
#        start=([1]=1    1    1    1    1    1    1    1    1    1     1     1     1   1     1     1     1    1   1   1   1   1   1    1    1    1    1    1    1    1    1    1    1    1    1    1     1     1     1     1     11    1     11)
#	  end=([1]=1813 1399 1079 833  643  496  383  296  228  176   136   105   81  63    49    38    29   23  20  20  20  20  20   20   20   20   20   20   20   20   20   20   20   20   20   20    20    20    20    10    20    10    20)  
 
    if [ -n "$ISIS" ]; then
	if [ ${jobSpec:0:1} = "W" ] ; then
          if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	    BuildIsisScriptList 1 11 12
	    BuildIsisScriptList 2 13 14
	    BuildIsisScriptList 3 15 16
	    BuildIsisScriptList 4 17 18
	    BuildIsisScriptList 5 19 20
	    BuildIsisScriptList 6 21 23
	    BuildIsisScriptList 7 24 26
	    BuildIsisScriptList 8 27 28
          else
	    BuildIsisScriptList 1 1 44
          fi
	fi
	if [ ${jobSpec:0:1} = "V" ] ; then
          if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	   #For ksaomVBF ~1:20 
#             For ksallVBF: set 1 about 24 hours <=10 TeV
	    BuildIsisScriptList 1 1  4
	    BuildIsisScriptList 2 5  9
	    BuildIsisScriptList 3 10 15
	    BuildIsisScriptList 4 16 24
	    BuildIsisScriptList 5 25 32
	    BuildIsisScriptList 6 33 34
	    BuildIsisScriptList 7 35 35
	    BuildIsisScriptList 8 36 36

# High >10 TeV 48 hrs?
#	    BuildIsisScriptList 1 37  37
#	    BuildIsisScriptList 2 38  38
#	    BuildIsisScriptList 3 39  39
#	    BuildIsisScriptList 4 40  40
#	    BuildIsisScriptList 5 41  41
#	    BuildIsisScriptList 6 42  42
#	    BuildIsisScriptList 7 43  43
#	    BuildIsisScriptList 8 44  44

          else
	    BuildIsisScriptList 1 1 44
          fi
	fi
    fi


#CARVER
   if [ -n "$CARVER" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************

           let iEntryStart=1
#           let iEntryEnd=44
	   let iEntryEnd=44

#Reverse order (prefered)
	   let j=$iEntryEnd
           while test $j -ge $iEntryStart
            do	
               if test $j -le 19
                then
                  BuildAndSubmitCarverJobs $j 
	        else
                  #BuildAndSubmitLargeCarverJobs $j
                  BuildAndSubmitCarverJobs $j 
	       fi
               let j=j-1		
            done

#normal order
#	   let j=$iEntryStart
#           while test $j -le $iEntryEnd
#            do	
#               BuildAndSubmitCarverJobs $j 
#	       #BuildAndSubmitLargeCarverJobs $j
#	       j=$((j+1))		
#            done

    fi
#HANSEN
   if [ -n "$HANSEN" ]; then
    #**********************************************************************
    #Submit in reverse order so the longest start first.
    #**********************************************************************
      let iEntryStart=1
      let iEntryEnd=44

      #Reverse order (prefered)
      let j=$iEntryEnd
      while test $j -ge $iEntryStart
        do	
          if test $j -le 19  
          then
            BuildAndSubmitHansenJobs $j 
	  else
	    BuildAndSubmitHansenJobsSingly $j
          fi
          let j=j-1		
        done
    fi
#********************************************************************************


#PDSF
   if [ -n "$PDSF" ]; then
     #**********************************************************************
     #Submit in reverse order so the longest start first.
     #**********************************************************************

# *******************************************************************
#Folowing for making te.d files on PDSF with our 500 GByte limitation
#	    let iEntryStart=1      #Making te.d: First group: fits 500 Gbytes
#	    let iEntryEnd=27       #Use BuildAndSubmitPDSFJobArray
#
#	    let iEntryStart=28     #Making te.d: second group: fits 500 Gbytes
#	    let iEntryEnd=35       #Use BuildAndSubmitPDSFJobGroups @5 each
#
#	    let iEntryStart=36     #Making te.d: third group: fits 500 Gbytes
#	    let iEntryEnd=39       #Use BuildAndSubmitPDSFJobGroups @5 each
# 
#	    let iEntryStart=40     #Making te.d: third group: fits 500 Gbytes
#	    let iEntryEnd=44       #Use BuildAndSubmitPDSFJobGroups @5 each
#                   or
#	    let iEntryStart=40     #Making te.d: third groupSecond energy set: fits 500 Gbytes
#	    let iEntryEnd=43       #Use BuildAndSubmitPDSFJobGroups @5 each
# *********************************************************************

           let iEntryStart=44
	   let iEntryEnd=44

#           let iEntryStart=1
#	   let iEntryEnd=44
	    let j=$iEntryEnd
            while test $j -ge $iEntryStart
            do	
               #BuildAndSubmitPDSFJobGroups $j 5
               BuildAndSubmitPDSFJobArray $j
	       j=$((j-1))		
            done
    fi
# ********************************************

}
#********************************************************************************
#********************************************************************************

function BuildAndSubmitHansenJobs
#**********************************************************************
# Cause HANSEN cluster jobs to be submitted.
# This is the "all showers of one energy in sequence on one core"
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}     
 echo Entry:  $pr $eGeV $showerStart $showerEnd

 sgeFile=$lcl'/K'$eGeV$pr.pbs
 echo "#"PBS -q $QUEUE                         >$sgeFile
 echo "#"PBS -l walltime=24:00:00             >>$sgeFile
 echo source /etc/profile                     >>$sgeFile
 echo module load gcc/4.5.1                   >>$sgeFile
 echo lcl=$PBS_O_WORKDIR                      >>$sgeFile
 echo cd $lcl                                 >>$sgeFile
 echo $ksScript $eGeV $pr $showerStart  \\    >>$sgeFile
 echo $showerEnd $datadir $workingDir   \\    >>$sgeFile
 echo ">>"$lcl"/ksProduction_"$eGeV$pr".log"  >>$sgeFile
 chmod 700 $sgeFile
 qsub -V -e k$eGeV$pr.err -o k$eGeV$pr.log $sgeFile 
}

function BuildAndSubmitHansenJobsSingly 
#**********************************************************************
# Cause HANSEN serial jobs to be submitted.
# This version submits 1 job per shower. Useful for high energies.
# Don't use for low energies. The queue manager whill probably chokes 
# with too many jobs in the queue. Don't know what "too many" is yet.
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}     
 echo Entry:  $pr $eGeV $showerStart $showerEnd

 let i=showerStart
 while test $i -le $showerEnd
  do
   sgeFile=$lcl'/K'$eGeV'd'$i$pr.pbs
   echo "#"PBS -q $QUEUE                                   >$sgeFile
   echo "#"PBS -l walltime=24:00:00                       >>$sgeFile
   if test $1 -ge 19
     then
      echo "#PBS -l mem=10GB"                             >>$sgeFile
   fi
   echo source /etc/profile                               >>$sgeFile
   echo module load gcc/4.5.1                             >>$sgeFile
   echo lcl=$PBS_O_WORKDIR                                >>$sgeFile
   echo cd $lcl                                           >>$sgeFile
   echo $ksScript $eGeV $pr $i $i $datadir $workingDir \\ >>$sgeFile
   echo ">>"$lcl"/ksProduction_"$eGeV'd'$i$pr".log"       >>$sgeFile

   chmod 700 $sgeFile
   qsub -V -e k$eGeV'd'$i$pr.err -o k$eGeV'd'$i$pr.log $sgeFile 
   let i=i+1
  done
}
#**********************************************************************

function BuildAndSubmitCarverJobs
#**********************************************************************
# Cause Carver cluster jobs to be submitted.
# This is the "all showers of one energy in sequence on one core"
# This is a standard way to submit Carver jobs
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}     
 echo Entry:  $pr $eGeV $showerStart $showerEnd

 sgeFile=$lcl'/K'$eGeV$pr.pbs
 echo "#"!/bin/bash                            >$sgeFile
 echo "#"PBS -l walltime=12:00:00             >>$sgeFile
 echo "#"PBS -l gres=gscratch%project         >>$sgeFile
 echo cd $lcl                                 >>$sgeFile
 echo $ksScript $eGeV $pr $showerStart  \\    >>$sgeFile
 echo $showerEnd $datadir $workingDir   \\    >>$sgeFile
 echo ">>"$lcl"/ksProduction_"$eGeV$pr".log"  >>$sgeFile

 chmod 700 $sgeFile
 qsub -q $CarverQueue -V -e k$eGeV$pr.err -o k$eGeV$pr.log $sgeFile 
}

function BuildAndSubmitCarverJobsSingly 
#**********************************************************************
# Cause Carver serial jobs to be submitted.
# This version submits 1 job per shower. 
# This is standard way to submit to Carver
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}     
 echo Entry:  $pr $eGeV $showerStart $showerEnd

 let i=showerStart
 while test $i -le $showerEnd
  do
   sgeFile=$lcl'/K'$eGeV'd'$i$pr.pbs
   echo "#"!/bin/bash                                      >$sgeFile
   echo "#"PBS -l walltime=12:00:00                       >>$sgeFile
   echo "#"PBS -l gres=gscratch%project                   >>$sgeFile
   if test $1 -ge 25
     then
      echo "#PBS -l pvmem=8GB"                            >>$sgeFile
   fi	
   echo cd $lcl                                           >>$sgeFile
   echo $ksScript $eGeV $pr $i $i $datadir $workingDir \\ >>$sgeFile
   echo ">>"$lcl"/ksProduction_"$eGeV'd'$i$pr".log"       >>$sgeFile

   chmod 700 $sgeFile
   qsub -q $CarverQueue -V -e k$eGeV'd'$i$pr.err -o k$eGeV'd'$i$pr.log $sgeFile 
   let i=i+1
  done
}

function BuildAndSubmitLargeCarverJobs
#**********************************************************************
#  This routine never used. Outdated due to disapearance of Magellan
# *********************************************************************
# Cause Carver multi-node cloud jobs to be submitted.
# Since we have lots and lots of nodes 1 job per shower
# This version attempts to run n(<8) jobs per node leaving the rest of the 
# nodes empty. This reduces I/O conflicts and greatly speeds processing
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}        
 echo Entry: $1  $pr $eGeV $showerStart $showerEnd

 #*****************************************************************
 # This is like a job arry submission limited to a max of
 #  n jobs per node
 # Purpose is to not overload the  IO of a node (conisting of 8 cores(cpus))
 # which can slow things down by an order of magnitude or more for the
 # large files
 #*****************************************************************

 let coresPerNode=3
 let numJobs=(showerEnd-showerStart+1)
 let numNodes=numJobs/coresPerNode+1

 sgeFile=$lcl'/K'$eGeV$pr.pbs
 echo "#"PBS -S /bin/bash                             >$sgeFile
 echo "#"PBS -l walltime=4:00:00,pvmem=5gb          >>$sgeFile
 echo "#"PBS -l nodes=$numNodes                      >>$sgeFile
 echo "#"PBS -l gres=gscratch%project                >>$sgeFile
 echo cd "$"PBS_O_WORKDIR                            >>$sgeFile
 
 let i=showerStart  
 let node=0
 while test $node -lt $numNodes 
  do
   let k=1
   while test $k -le $coresPerNode
    do
     if test $i -le $showerEnd
      then
       magFile=Mag$eGeV$pr'd'$i.scr
       echo "#"!/bin/bash                                      >$magFile
       echo "#"PBS -l walltime=48:00:00                       >>$magFile
       echo $ksScript $eGeV $pr $i $i $datadir $workingDir \\ >>$magFile
       echo ">>"$lcl"/ksProduction_"$eGeV"d"$i"_"$pr".log "   >>$magFile
 
       chmod 700 $magFile

       echo pbsdsh -n $node $lcl'/'$magFile' &'        >>$sgeFile
     fi
     let i=i+1
     let k=k+1
   done
   let node=node+1
 done
 echo wait                                           >>$sgeFile

 chmod 700 $sgeFile
# ************************************************************************
# Note submission is to the regular Carver queue. We are limited here to
# having 150 "submissions" run at a time.  However it usually takes hours/days 
# before any of the submitted jobs actually run, so the limit of 8 is never 
# even approached. Because of the difficulty of ever geting the jobs to run,
# even after waiting days in the queue, this isn't a particulay good way to 
# run things..
# ************************************************************************
 qsub -q reg_small  -V -e k$eGeV$pr'd'$showerStart.err -o k$eGeV$pr'd'$showerStart.log $sgeFile
}



function BuildAndSubmitCarverJobArray
#**********************************************************************
# Cause Carver cluster jobs to be submitted using Job arrays.
# Since we have lots and lots of nodes 1 job per shower
# Need to limit number in each job array submission to 1024
# We don't use this since the Carver queue manager probably can't handle lots of 
# short jobs. This is just here for future reference.
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 eGeV=${energy[$1]}
 let numBlock=1024


 let numJobBlock=showerEnd-showerStart+1
 let numArraySubs=numJobBlock/numBlock
 if test $numArraySubs -gt 0
  then
   let numJobBlock=numBlock
 fi
 let k=showerStart

 while test $k -le $showerEnd
  do
   let kend=$k+numJobBlock-1
   if test $kend -gt $showerEnd
    then
     let kend=showerEnd
   fi

   echo Entry:  $pr  $eGeV $k $kend

   sgeFile=$lcl'/K'$eGeV$parspec.pbs
   echo "#"!/bin/bash                                            >$sgeFile
   echo "#"PBS -l gres=gscratch%project                         >>$sgeFile
   echo let i=\$PBS_ARRAYID                                     >>$sgeFile
   echo cd $lcl                                                 >>$sgeFile
   echo LOGFILE=$lcl"/ksProduction_"$eGeV'd'\$i\'$parspec.log\' >>$sgeFile
   echo echo LOGFILE: \$LOGFILE                                 >>$sgeFile
   echo $ksScript $eGeV $parspec  \$i  \$i $datadir \\          >>$sgeFile
   echo $workingDir '>'\$LOGFILE                                >>$sgeFile

   chmod 700 $sgeFile
   qsub -q $CarverQueue  -t $k'-'$kend  -V -e k$eGeV.err -o k$eGeV.log $sgeFile 
   let k=kend+1

  done
}


function BuildAndSubmitPDSFJobs
#**********************************************************************
# Cause PDSF cluster jobs to be submitted.
# Since we have lots and lots of nodes 1 job per shower
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 let i=$showerStart
 eGeV=${energy[$1]}

 echo Entry:  $pr $eGeV $showerStart $showerEnd

 while test $i -le $showerEnd
 do
      sgeFile=$lcl'/K'$eGeV'd'$i$parspec.pbs
      echo "#"!/bin/bash                                   >$sgeFile
      echo cd $lcl                                        >>$sgeFile
      echo $ksScript $eGeV $parspec  $i \\                >>$sgeFile
      echo $i $datadir $workingDir                \\      >>$sgeFile
      echo ">>"$lcl"/ksProduction_"$eGeV"d"$i"_"$pr".log" >>$sgeFile

      chmod 700 $sgeFile
      qsub  -V -e k$eGeV'd'$i.err -o k$eGeV'd'$i.log $sgeFile 
      i=$((i+1))			#do next shower
 done
}

function BuildAndSubmitPDSFJobArray
#**********************************************************************
# Cause PDSF cluster jobs to be submitted using Job arrays.
# Since we have lots and lots of nodes 1 job per shower
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 let i=$showerStart
 eGeV=${energy[$1]}
      
 echo Entry:  $pr  $eGeV $showerStart $showerEnd

 sgeFile=$lcl'/K'$eGeV$parspec.pbs
 echo "#"!/bin/bash                                            >$sgeFile
 echo let i=\$SGE_TASK_ID                                     >>$sgeFile
 echo cd $lcl                                                 >>$sgeFile
 echo LOGFILE=$lcl"/ksProduction_"$eGeV'd'\$i\'$parspec.log\' >>$sgeFile
 echo echo LOGFILE: \$LOGFILE                                 >>$sgeFile
 echo $ksScript $eGeV $parspec  \$i \$i $datadir \\           >>$sgeFile
 echo $workingDir  '>'\$LOGFILE                               >>$sgeFile

 chmod 700 $sgeFile
 qsub -t $showerStart':'$showerEnd  -V -e k$eGeV.err -o k$eGeV.log $sgeFile 
}

function BuildAndSubmitPDSFJobGroups
#**********************************************************************
# Cause PDSF cluster jobs to be submitted in groups of $3.
# We have lots and lots of nodes but only 500 gbytes so submit
# jobs in groups of $3 (like we do on other clusters)
#**********************************************************************
{
 pr=$parspec
 sub=${pr%%mv*}mv
 let showerStart=${start[$1]}
 let showerEnd=${end[$1]}
 let i=$showerStart
 eGeV=${energy[$1]}


 if [ -z $2 ]; then
    let clusterSize=$showerEnd
 else
    let clusterSize=$2
 fi
 echo Entry:  $1 $pr $eGeV $showerStart $showerEnd $clusterSize

 while test $i -le $showerEnd
 do
   let clusterEnd=$((i+clusterSize-1))
   if [ $clusterEnd -gt  $showerEnd ]; then
     clusterEnd=$showerEnd
   fi

   sgeFile=$lcl'/K'$eGeV'd'$i"-"$clusterEnd$parspec.pbs
   echo "#"!/bin/bash                                                       >$sgeFile
   echo cd $lcl                                                            >>$sgeFile
   echo LOGFILE=$lcl"/ksProduction_"$eGeV'd'$i"-"$clusterEnd$parspec".log" >>$sgeFile
   echo echo LOGFILE: \$LOGFILE                                            >>$sgeFile
   echo $ksScript $eGeV $parspec  $i $clusterEnd $datadir $workingDir \\   >>$sgeFile
   echo '>'\$LOGFILE                                                       >>$sgeFile

   chmod 700 $sgeFile
   qsub -V -e k$eGeV.err -o k$eGeV.log $sgeFile 
 

   i=$((clusterEnd+1))			#do next shower
 done
}



function BuildIsisScriptList()
#**********************************************************************
# Causes sub-script list to be created and run
#**********************************************************************
{
 pr=$parspec
 jobScript=$lcl'/js'$1'_'$jobSpec'.scr'
 let processStart=$2
 let processEnd=$3
 let i=$processStart

 while test $i -le $processEnd
 do
    eGeV=${energy[$i]}
    let showerStart=${start[$i]}
    let showerEnd=${end[$i]}
    echo Entry: $i  $parspec $eGeV $showerStart $showerEnd 

    if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	logFile=">>"$lcl"/ksProduction_"$i"_"$pr".log"
    else
	logFile=' '
    fi
  
    echo $ksScript $eGeV $parspec  $showerStart \\   >>$jobScript
    echo $showerEnd $datadir $workingDir        \\   >>$jobScript
    echo $logFile                                    >>$jobScript

    i=$((i+1))			#do next process
 done
}


#*************************************************************
#Start of main script.
#*************************************************************
lcl="$PWD"

host=$(hostname)
echo host: $host

hostString=${host:0:6}
if test  "$hostString" = "cvrsvc"  #Are we running on Carver
then
  CARVER=enabled
  CarverQueue=serial
  echo ***Carver Cluster***
fi

hostString=${host:0:6}
if test  "$hostString" = "hansen"  #Are we running on Hansen
then
  HANSEN=enabled
  QUEUE1=physics
  QUEUE2=standby
  QUEUE=$QUEUE1
fi

hostString=${host:0:4}
if test  "$hostString" = "pdsf"  #Are we running on PDSF
then
  PDSF=enabled
fi
if test  "$hostString" = "isis"  #Are we running on ISIS
then
  ISIS=enabled
fi



#script directory
sdr=$KASCADEBASE"/scripts"
ksscpt=$2

#Check to see if the user specified the script wiht the .scr extention
ksscpt=${ksscpt%.scr}

            #Assume local copy of script
kssc=${ksscpt##*/}
if test "$kssc" = "$ksscpt"
then
  #ksScript=$sdr'/'$kssc'.scr' #ksall: Makes seg,pe,pes,te files. Keeps te files
  ksScript=$lcl'/'$kssc'.scr' #ksall: Makes seg,pe,pes,te files. Keeps te files
                          #ksaom: Makes .root  files from te files(depreciated)
                           #ksaomVBF: Makes .vbf files from te files
                          #ksarraytriggerVBF: Makes array  .vbf files
                          #ksallVBF:Does everything from ksKascade to 
                          #         ksArrayTrigger
else
    ksScript=$ksscpt'.scr'
fi
echo ksScript: $ksScript
echo kssc: $kssc

let lastJob=8
if [ "$kssc" = "ksMissingVBF" ] || [ "$kssc" = "ksMissingTE" ]; then
    let lastJob=1
fi


#ISIS
if [ -n "$ISIS" ]; then
    if test ${lcl:1:4} = "disk"
    then
       dataDirBase=${lcl:0:6}'/simulations'
    else
       dataDirBase=/simulations
    fi
    mkdir -vp $dataDirBase
    workingDir=$lcl

    let jobNum=1
    while test $jobNum -le $lastJob
    do
	    #define job script name
	JobScript=$lcl'/js'$jobNum'_'$1'.scr'
	    #Initialze the script files
	echo echo Starting $JobScript >$JobScript
    jobNum=$((jobNum+1))
    done
fi



if [ -n "$CARVER" ]; then
    dataDirBase=/project/projectdirs/m1304/veritas_CM/simulations
    echo Carver Data Dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$SCRATCH
fi

if [ -n "$HANSEN" ]; then
    dataDirBase=$RCAC_SCRATCH'/simulations'
    echo Hansen Data dir: $dataDirBase
    mkdir -vp $dataDirBase
    workingDir=$RCAC_SCRATCH

fi

user=$USER

#Fuctions specify which nodes are to be used ("on" or "off")
#Funtions also specify the energy and specify the starting and ending shower 
#IDs.
#See bottom for numbers and energies for gammas,protons and he4

#******************************************************************************
# Set up arrays for node submission and submit
#*****************************************************************************
let pspecset=0
maxMem=240MB
WALLTIME=20:00:00
jobSpec=$1


if [ ${jobSpec:1:1} = "W" ]; then
   dataDirBase=$dataDirBase'/whipple'
   mkdir -vp $dataDirBase
fi

if [ ${jobSpec:1:1} = "V" ] || [ ${jobSpec:1:1} = "U" ]; then
    dataDirBase=$dataDirBase'/veritas'
    mkdir -vp $dataDirBase
fi

if [ ${jobSpec:2:2} = "CR" ]; then      #CosmicRay (P and He4_)
                                        
    AtmSpec=${jobSpec:0:1}             #gets S(for summer) from  
                                        #SWCR20DegN0.5Deg50mv1234M2
    TelSpec=${jobSpec:1:1}              #gets W from CWCR20DegN0.5Deg50mv1234M2
    spec=${jobSpec#*CR}                 #gets 20DegN0.3Deg50mv1234M2 from 
                                        #WWCR20DegN0.3Deg50mv1234M2

    if [ -n "$CARVER" ] || [ -n "$HANSEN" ]; then
      #Protons
       protonParspec=$AtmSpec$TelSpec'P'$spec
       protonDatadir="$dataDirBase/protons"
       echo CR:Proton Dir: $protonDatadir
       mkdir -vp $protonDatadir

#Helium4
       he4Parspec=$AtmSpec$TelSpec'He4_'$spec
       he4Datadir="$dataDirBase/he4"
       echo CR:He4 Dir: $he4Datadir
       mkdir -vp  $he4Datadir
 
       CosmicRay
       let pspecset=1;
    else
       parspec=$AtmSpec$TelSpec'P'$spec   #gives SVP20DegN0.3Deg50mv1234M2ABCD
       datadir="$dataDirBase/protons"     #from SVCR20DegN0.3Deg50mv1234M2ABCD
       mkdir -vp $datadir
       Protons

       datadir="$dataDirBase/he4"
       parspec=$AtmSpec$TelSpec'He4_'$spec
       mkdir -vp $datadir
       Helium4
       let pspecset=1;
    fi
fi

if [ ${jobSpec:2:1} = "E" ] ; then 
    parspec=$1 
    datadir="$dataDirBase/electrons"
    mkdir -vp $datadir
    Electrons
    let pspecset=1;
fi

if [ ${jobSpec:2:1} = "P" ] ; then 
    parspec=$1 
    datadir="$dataDirBase/protons"
    mkdir -vp $datadir
    Protons
    let pspecset=1;
fi

if [ ${jobSpec:2:4} = "He4_" ] ; then 
    parspec=$1 
    datadir="$dataDirBase/he4"
    mkdir -vp $datadir
    Helium4
    let pspecset=1;
fi

if [ ${jobSpec:2:1} = "G" ]; then
    parspec=$1
    datadir="$dataDirBase/gammas"
    mkdir -vp $datadir 
    Gammas
    let pspecset=1;
fi

 echo datadir $datadir

if [ $pspecset -ne 1 ]; then
    echo No such Particle spec: $1
    exit
fi

#ISIS
if [ -n "$ISIS" ]; then
   
    let jobNum=1
    while test $jobNum -le $lastJob
    do
	    #define job script name
	JobScript=$lcl'/js'$jobNum'_'$jobSpec'.scr'
	if [ "$kssc" != "ksMissingVBF" ] && [ "$kssc" != "ksMissingTE" ]; then
	    JobScriptLog=$lcl'/js'$jobNum'_'$jobSpec'.log'
	    #Initialze the script files
	    chmod 777 $JobScript
	    $JobScript  >$JobScriptLog &
	else
	    #Initialze the script files
	    chmod 777 $JobScript
	    $JobScript 
	fi
    jobNum=$((jobNum+1))
    done
fi


#Nothing for CARVER,HANSEN


###########################################################################
#Arguments for ksScript
#$1 primary Energy in GeV (integer only)
#$2 Shower type specification string (To be included in config file names and 
#                              in shower names:Like P1W,G1W, He4_1W, G20N0.3V)
#$3 Lowest flie id
#$4 Highest file id.
#$5 data disk directory.(Where output Te/root  files go, cannot be blank!!!)
#############################################################################
